# تقرير مراجعة خطة فصل الصالات والموردين

**تاريخ المراجعة**: 2025-01-07  
**الهدف**: التحقق من التعارضات والتكرار في الخطة المقترحة مع البنية الحالية

---

## ملخص تنفيذي

✅ **الخطة قابلة للتنفيذ** لكن تحتاج إلى بعض التعديلات لتجنب التعارضات  
⚠️ **عدد التعارضات المكتشفة**: 6 تعارضات محتملة  
🔄 **عدد التكرارات**: 3 حالات تكرار  
💡 **تحسينات مقترحة**: 8 نقاط

---

## القسم الأول: التعارضات المكتشفة

### ⚠️ التعارض 1: حقل `unit_price` في Material
**الوضع الحالي**:
- `Material.unit_price` موجود بالفعل ويُستخدم كـ "سعر الوحدة"
- يُستخدم في حسابات التكلفة في `OrderCost` و `MaterialConsumption`

**الخطة المقترحة**:
- تريد تحويل `unit_price` ليصبح "سعر التكلفة"
- إضافة منطق لحساب سعر التكلفة (افتراضي/متوسط/آخر فاتورة)

**التعارض**:
- الاسم الحالي `unit_price` غامض - هل هو سعر البيع أم التكلفة؟
- الخطة تفترض أنه سعر التكلفة، لكن الكود يستخدمه في أماكن متعددة

**الحل المقترح**:
```python
class Material(db.Model):
    # الحقول الموجودة
    unit_price = db.Column(db.Float, default=0)  # إعادة تسمية → cost_price
    
    # حقول جديدة
    cost_price = db.Column(db.Float, default=0)  # سعر التكلفة
    purchase_price = db.Column(db.Float, default=0)  # آخر سعر شراء
    cost_price_mode = db.Column(db.String(30), default='purchase_price_default')
    selling_price = db.Column(db.Float, default=0)  # سعر البيع (اختياري)
```

**التوصية**: 
- إعادة تسمية `unit_price` → `cost_price` أو `unit_cost`
- إضافة حقل منفصل `purchase_price` لسعر الشراء الأخير
- Migration لنقل البيانات الحالية

---

### ⚠️ التعارض 2: حقل `payment` مُستخدم للعملاء
**الوضع الحالي**:
- `Payment` model موجود ويُستخدم لمدفوعات **العملاء** للطلبات
- له علاقة مع `Order` وحقول: amount, payment_type, payment_method, received_by

**الخطة المقترحة**:
- إضافة `SupplierPayment` لمدفوعات **الموردين**

**التعارض**:
- قد يحدث لبس بين `Payment` (عملاء) و `SupplierPayment` (موردين)
- نفس الحقول تقريباً في النموذجين

**الحل المقترح**:
```python
# إعادة تسمية للوضوح
class CustomerPayment(db.Model):  # بدل Payment
    __tablename__ = 'customer_payments'
    # ... نفس الحقول

class SupplierPayment(db.Model):
    __tablename__ = 'supplier_payments'
    # ... حقول مشابهة
```

**التوصية**:
- إما إعادة تسمية `Payment` → `CustomerPayment` للوضوح
- أو الإبقاء على `Payment` مع توثيق واضح أنه للعملاء فقط
- **الأفضل**: ترك `Payment` كما هو (مفهوم من السياق) وإضافة `SupplierPayment`

---

### ⚠️ التعارض 3: `showroom_id` مع Customer
**الوضع الحالي**:
- `Customer` ليس لديه `showroom_id`
- عميل واحد قد يطلب من أكثر من صالة

**الخطة المقترحة**:
- إضافة `showroom_id` إلى `Customer`

**التعارض**:
- إذا أضفنا `showroom_id` إلى Customer، فهذا يعني عميل واحد لكل صالة
- لكن نفس العميل قد يذهب لصالتين مختلفتين

**الحل المقترح**:
**الخيار A** (الموصى به):
- **لا** تضيف `showroom_id` إلى `Customer`
- أضف `showroom_id` فقط إلى `Order`
- العميل عام (shared)، لكن الطلبات مخصصة لكل صالة

**الخيار B**:
- إضافة `showroom_id` إلى `Customer`
- السماح بتكرار العميل عبر الصالات (نفس الاسم/الهاتف لكن showroom_id مختلف)
- إضافة unique constraint: `unique(name, phone, showroom_id)`

**التوصية**: **الخيار A** - عملاء عامون، طلبات خاصة بالصالة

---

### ⚠️ التعارض 4: تضارب في العلاقات (Relationships)
**الوضع الحالي**:
- يوجد تحذير SQLAlchemy سابق (تم حله):
  ```
  relationship 'Order.costs' conflicts with 'Order.order_costs'
  ```

**الخطة المقترحة**:
- إضافة المزيد من العلاقات (Showroom → Orders, Showroom → Materials, إلخ)

**التعارض المحتمل**:
- إضافة علاقات جديدة قد يُسبب تضاربات مشابهة
- خصوصاً `Showroom.materials` مع `Material.orders`

**الحل المقترح**:
- استخدام `backref` مع `overlaps` parameter:
```python
class Showroom(db.Model):
    materials = db.relationship('Material', backref='showroom', 
                                overlaps="showroom_materials")
```

**التوصية**: 
- تسمية العلاقات بعناية لتجنب التضارب
- استخدام `back_populates` بدل `backref` للوضوح
- اختبار SQLAlchemy relationships بعد كل إضافة

---

### ⚠️ التعارض 5: `ProductionStage` القديم
**الوضع الحالي**:
- يوجد إشارات إلى `ProductionStage` في الكود (السطور 1261, 1282)
- لكن النموذج الحالي هو `Stage` مع حقل `stage_type`

**الخطة المقترحة**:
- لا تذكر `ProductionStage`

**التعارض**:
- كود قديم يشير إلى نموذج غير موجود

**الحل المقترح**:
- تنظيف الكود من إشارات `ProductionStage` القديمة
- استخدام `Stage` فقط مع `stage_type='إنتاج'`

**التوصية**: تنظيف الكود قبل التنفيذ

---

### ⚠️ التعارض 6: سياسات التسعير المعقدة
**الوضع الحالي**:
- لا يوجد منطق لحساب أسعار معقدة
- `unit_price` يُحدّث يدوياً

**الخطة المقترحة**:
- 3 سياسات تسعير: افتراضي، متوسط مرجّح، آخر فاتورة
- حساب تلقائي عند إضافة فاتورة شراء

**التعارض**:
- قد يُسبب مشاكل في البيانات الحالية
- المستخدمون اعتادوا على تعديل السعر يدوياً

**الحل المقترح**:
- إضافة حقل `allow_manual_price_edit` على مستوى Material
- إضافة حقل `price_locked` لمنع التعديل التلقائي إذا عُدّل يدوياً
- Audit log لتتبع تغييرات الأسعار

**التوصية**: تطبيق تدريجي مع خيار Opt-in

---

## القسم الثاني: التكرارات المكتشفة

### 🔄 التكرار 1: دفعات الموردين
**الخطة**:
- `SupplierPayment.invoice_id` (nullable)
- `SupplierPayment.supplier_id`

**التكرار**:
- إذا كان `invoice_id` موجود، يمكن الحصول على `supplier_id` من الفاتورة
- لا حاجة لتكرار `supplier_id`

**التحسين**:
```python
class SupplierPayment(db.Model):
    invoice_id = db.Column(...)  # required
    # إزالة supplier_id - نحصل عليه من invoice.supplier_id
    
    @property
    def supplier_id(self):
        return self.invoice.supplier_id if self.invoice else None
```

---

### 🔄 التكرار 2: إجماليات الفواتير
**الخطة**:
- `PurchaseInvoice.total_amount`
- `PurchaseInvoice.paid_amount`
- `PurchaseInvoice.remaining_amount` (computed)

**التكرار**:
- `remaining_amount` يُحسب من الأول والثاني
- لا حاجة لحقل منفصل

**التحسين**:
```python
class PurchaseInvoice(db.Model):
    total_amount = db.Column(...)
    # إزالة paid_amount - نحسبه من SupplierPayments
    
    @property
    def paid_amount(self):
        return sum(p.amount for p in self.payments)
    
    @property
    def remaining_amount(self):
        return self.total_amount - self.paid_amount
```

---

### 🔄 التكرار 3: line_total في PurchaseInvoiceItem
**الخطة**:
```python
line_total = quantity * purchase_price
```

**التكرار**:
- يمكن حسابه تلقائياً، لا حاجة لتخزينه

**التحسين**:
```python
class PurchaseInvoiceItem(db.Model):
    quantity = db.Column(...)
    purchase_price = db.Column(...)
    # إزالة line_total
    
    @property
    def line_total(self):
        return self.quantity * self.purchase_price
```

**ملاحظة**: إذا كنت تريد تخزينه للأداء، أضف فهرس عليه

---

## القسم الثالث: تحسينات مقترحة

### 💡 تحسين 1: إضافة Soft Delete
**المشكلة**: حذف فيزيائي قد يفقد بيانات مهمة

**التحسين**:
```python
# إضافة لجميع النماذج
is_active = db.Column(db.Boolean, default=True)
deleted_at = db.Column(db.DateTime, nullable=True)
deleted_by = db.Column(db.String(100), nullable=True)

# Helper method
def soft_delete(self):
    self.is_active = False
    self.deleted_at = datetime.utcnow()
    self.deleted_by = current_user.username
```

---

### 💡 تحسين 2: Audit Trail
**التحسين**: إضافة جدول لتتبع التغييرات
```python
class AuditLog(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    table_name = db.Column(db.String(50))
    record_id = db.Column(db.Integer)
    action = db.Column(db.String(20))  # create, update, delete
    field_name = db.Column(db.String(50))
    old_value = db.Column(db.Text)
    new_value = db.Column(db.Text)
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    showroom_id = db.Column(db.Integer, db.ForeignKey('showroom.id'))
```

**الفائدة**: تتبع من غيّر ماذا ومتى (مهم للأسعار والمخزون)

---

### 💡 تحسين 3: فهارس الأداء
**التحسين**: إضافة فهارس مركبة
```python
class Order(db.Model):
    # ...
    __table_args__ = (
        db.Index('idx_showroom_status', 'showroom_id', 'status'),
        db.Index('idx_showroom_date', 'showroom_id', 'order_date'),
    )

class PurchaseInvoice(db.Model):
    # ...
    __table_args__ = (
        db.Index('idx_showroom_supplier', 'showroom_id', 'supplier_id'),
        db.Index('idx_invoice_date', 'invoice_date'),
    )
```

---

### 💡 تحسين 4: Validation
**التحسين**: إضافة Validators
```python
from sqlalchemy.orm import validates

class Material(db.Model):
    # ...
    
    @validates('cost_price', 'purchase_price', 'selling_price')
    def validate_price(self, key, value):
        if value < 0:
            raise ValueError(f"{key} cannot be negative")
        return value
    
    @validates('quantity_available')
    def validate_quantity(self, key, value):
        if value < 0:
            raise ValueError("Quantity cannot be negative")
        return value
```

---

### 💡 تحسين 5: Settings Model
**التحسين**: نموذج مركزي للإعدادات
```python
class SystemSettings(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    key = db.Column(db.String(100), unique=True, nullable=False)
    value = db.Column(db.Text)
    value_type = db.Column(db.String(20))  # string, int, bool, json
    category = db.Column(db.String(50))  # pricing, permissions, etc
    showroom_id = db.Column(db.Integer, nullable=True)  # null = system-wide
    
# أمثلة:
# key='default_cost_price_mode', value='purchase_price_default'
# key='allow_manual_cost_edit', value='true', value_type='bool'
```

---

### 💡 تحسين 6: Multi-tenancy Helper
**التحسين**: دالة مساعدة لتصفية الصلاحيات
```python
# في ملف utils.py أو helpers.py
def get_scoped_query(model_class, user=None):
    """
    ترجع Query مصفّى حسب showroom_id للمستخدم
    """
    user = user or current_user
    query = model_class.query
    
    # المدير يرى كل شيء (أو حسب فلتر واجهة)
    if user.role == 'مدير':
        showroom_filter = session.get('showroom_filter')  # من واجهة
        if showroom_filter and showroom_filter != 'all':
            query = query.filter_by(showroom_id=showroom_filter)
    
    # موظفون آخرون يرون صالتهم فقط
    elif user.showroom_id:
        query = query.filter_by(showroom_id=user.showroom_id)
    
    return query

# استخدام:
# orders = get_scoped_query(Order).filter_by(status='مفتوح').all()
```

---

### 💡 تحسين 7: Decorator للحماية
**التحسين**: Decorator لحماية المسارات
```python
from functools import wraps

def require_showroom_access(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        showroom_id = kwargs.get('showroom_id') or request.args.get('showroom_id')
        
        # المدير له صلاحية كل الصالات
        if current_user.role == 'مدير':
            return f(*args, **kwargs)
        
        # موظف بصالة محددة
        if current_user.showroom_id == int(showroom_id):
            return f(*args, **kwargs)
        
        flash('ليس لديك صلاحية للوصول إلى هذه الصالة', 'danger')
        return redirect(url_for('dashboard'))
    
    return decorated_function

# استخدام:
@app.route('/orders/<int:showroom_id>')
@login_required
@require_showroom_access
def orders(showroom_id):
    # ...
```

---

### 💡 تحسين 8: Status Enum
**التحسين**: استخدام Enum بدل String للحالات
```python
from enum import Enum

class OrderStatus(str, Enum):
    OPEN = 'مفتوح'
    IN_PROGRESS = 'قيد التنفيذ'
    COMPLETED = 'مكتمل'
    DELIVERED = 'مسلّم'

class InvoiceStatus(str, Enum):
    OPEN = 'open'
    PARTIAL = 'partial'
    PAID = 'paid'
    OVERDUE = 'overdue'
```

**الفائدة**: منع أخطاء الكتابة، IntelliSense، Type Safety

---

## القسم الرابع: توصيات خطة التنفيذ

### المرحلة 1: تحضير وتنظيف (أسبوع 1)
1. ✅ تنظيف الكود من `ProductionStage` القديم
2. ✅ حل تضارب `Order.costs` و `Order.order_costs`
3. ✅ إعادة تسمية `Material.unit_price` → `cost_price`
4. ✅ إضافة Soft Delete للنماذج الحالية
5. ✅ كتابة Tests للوظائف الحالية (Regression Prevention)

### المرحلة 2: إضافة Showroom (أسبوع 2)
1. ✅ إنشاء نموذج `Showroom`
2. ✅ Migration: إضافة `showroom_id` للجداول
3. ✅ Migration: إنشاء صالة افتراضية وإسناد البيانات
4. ✅ تحديث `User` model بـ `showroom_id`
5. ✅ إضافة Helpers: `get_scoped_query()`, `@require_showroom_access`
6. ✅ تحديث جميع المسارات لتصفية showroom_id
7. ✅ Tests للعزل بين الصالات

### المرحلة 3: الموردين والفواتير (أسبوع 3-4)
1. ✅ إنشاء نماذج: Supplier, PurchaseInvoice, PurchaseInvoiceItem, SupplierPayment
2. ✅ إضافة مسارات CRUD للموردين
3. ✅ إضافة مسارات فواتير الشراء
4. ✅ منطق تحديث المخزون عند إضافة فاتورة
5. ✅ مسارات دفعات الموردين
6. ✅ حساب المتبقي والديون
7. ✅ Tests لتدفق الفواتير والدفعات

### المرحلة 4: سياسات التسعير (أسبوع 5)
1. ✅ إضافة `SystemSettings` model
2. ✅ إضافة حقول التسعير للـ Material
3. ✅ تطبيق منطق الحساب (افتراضي/متوسط/آخر فاتورة)
4. ✅ صفحة إعدادات أدوات المشرف
5. ✅ واجهة إدارة سياسات الأصناف
6. ✅ Audit Log للأسعار
7. ✅ Tests لسياسات التسعير

### المرحلة 5: الواجهات (أسبوع 6)
1. ✅ Selector الصالة في الـ navbar
2. ✅ صفحات الموردين (قائمة، إضافة، تعديل)
3. ✅ صفحات الفواتير (قائمة، إضافة، عرض)
4. ✅ صفحة دفعات الموردين
5. ✅ صفحة إعدادات التسعير
6. ✅ تحديث لوحة التحكم لعرض إحصائيات حسب الصالة

### المرحلة 6: التقارير والتحسينات (أسبوع 7)
1. ✅ تقارير حسب الصالة
2. ✅ تقرير التزامات الموردين
3. ✅ تقرير دوران المخزون
4. ✅ تقرير ربحية الصالات
5. ✅ تصدير CSV/PDF
6. ✅ تحسينات UX

---

## القسم الخامس: المخاطر والتحديات

### ⚠️ خطر 1: هجرة البيانات
**الخطر**: فقدان بيانات أثناء Migration
**التخفيف**: 
- نسخ احتياطية إلزامية قبل كل migration
- اختبار migrations في بيئة تطوير أولاً
- Rollback scripts جاهزة

### ⚠️ خطر 2: تعقيد الصلاحيات
**الخطر**: صعوبة إدارة الصلاحيات عبر الصالات
**التخفيف**:
- توحيد المنطق في Helpers
- توثيق واضح
- Testing شامل

### ⚠️ خطر 3: الأداء
**الخطر**: بطء الاستعلامات مع كثرة الصالات
**التخفيف**:
- فهارس مناسبة
- Caching للإعدادات
- Pagination للقوائم

### ⚠️ خطر 4: تعقيد الواجهة
**الخطر**: واجهة معقدة للمستخدم
**التخفيف**:
- UX بسيط وواضح
- Wizards للعمليات المعقدة
- تدريب المستخدمين

---

## القسم السادس: الخلاصة والتوصيات النهائية

### ✅ قرار التنفيذ
**الخطة قابلة للتنفيذ** بعد معالجة التعارضات المذكورة

### 🎯 أولويات التنفيذ
1. **عالية**: فصل الصالات (core functionality)
2. **عالية**: الموردين والفواتير (required for operations)
3. **متوسطة**: سياسات التسعير (can be added gradually)
4. **متوسطة**: Audit Log (important for compliance)
5. **منخفضة**: التقارير المتقدمة (nice to have)

### 📋 نقاط تحتاج قرار
1. **Customer.showroom_id**: عام أم خاص بالصالة؟ → **التوصية: عام**
2. **Material.unit_price**: إعادة تسمية أم إضافة حقول؟ → **التوصية: إضافة cost_price منفصل**
3. **Payment**: إعادة تسمية أم ترك كما هو؟ → **التوصية: ترك كما هو**
4. **Audit Log**: كامل أم للأسعار فقط؟ → **التوصية: البدء بالأسعار ثم التوسع**

### ⏱️ الوقت المتوقع
- **الحد الأدنى** (core features): 4-5 أسابيع
- **كامل** (مع التحسينات): 7-8 أسابيع
- **تدريب ومراقبة**: 2 أسبوع

### 💰 التكلفة التقديرية (من حيث الجهد)
- **تطوير**: 200-300 ساعة
- **اختبار**: 80-100 ساعة
- **توثيق**: 40-50 ساعة
- **التدريب**: 20-30 ساعة

---

## الملحق: أسئلة للمستخدم قبل التنفيذ

1. **هل لديك بيانات حالية في production؟** → يحدد استراتيجية Migration
2. **كم عدد الصالات المتوقع؟** → يحدد الأداء المطلوب
3. **هل تريد فصل كامل أم مشاركة بعض البيانات؟** → يحدد العزل
4. **من يدير الموردين - مركزي أم كل صالة؟** → يحدد `Supplier.showroom_id`
5. **هل تريد تطبيق Audit Log من البداية؟** → يحدد الأولويات
6. **ما هي سياسة التسعير المفضلة افتراضياً؟** → يحدد الإعدادات الأولية

---

**الخلاصة**: الخطة ممتازة ولكن تحتاج تعديلات طفيفة. جاهز للتنفيذ بعد موافقتك على التوصيات! ✨

