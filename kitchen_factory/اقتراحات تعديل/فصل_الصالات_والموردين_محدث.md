# خطة فصل الصالات وإدارة الموردين والتسعير - نسخة محدثة مع التوصيات

**آخر تحديث**: 2025-01-07  
**الإصدار**: 2.0 - مع دمج التوصيات من تقرير المراجعة

---

## الهدف العام
- عزل صلاحيات موظفي الاستقبال حسب الصالة (Showroom)
- فصل البيانات التشغيلية والمالية لكل صالة (multi-tenant style)
- **العملاء مشتركون بين الصالات** (يمكن رؤيتهم من جميع الصالات)
- تسجيل الصالة التي جاء منها كل طلب
- إضافة نظام مورّدين وفواتير شراء مع دفعات وديون
- بناء سياسة تسعير تكلفة مرنة مع Audit Trail
- تمكين إعدادات مركزية من أدوات المشرف للتحكم في سلوك التسعير
- Soft Delete لحماية البيانات المهمة

---

## الجزء الأول: فصل الصالات (Showrooms) - محدث

### نماذج جديدة/تعديلات

#### 1. نموذج Showroom (جديد)
```python
class Showroom(db.Model):
    __tablename__ = 'showrooms'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), unique=True, nullable=False)
    code = db.Column(db.String(20), unique=True)  # كود قصير للصالة
    address = db.Column(db.String(200))
    phone = db.Column(db.String(20))
    manager_name = db.Column(db.String(100))
    notes = db.Column(db.Text)
    is_active = db.Column(db.Boolean, default=True)
    
    # Soft Delete
    deleted_at = db.Column(db.DateTime)
    deleted_by = db.Column(db.String(100))
    
    # Timestamps
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
    
    # العلاقات
    users = db.relationship('User', back_populates='showroom')
    orders = db.relationship('Order', back_populates='showroom')
    materials = db.relationship('Material', back_populates='showroom')
    suppliers = db.relationship('Supplier', back_populates='showroom')
```

#### 2. User (تعديل)
```python
class User(UserMixin, db.Model):
    # الحقول الموجودة
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(100), unique=True, nullable=False)
    password = db.Column(db.String(200), nullable=False)
    role = db.Column(db.String(50), nullable=False)
    
    # حقول جديدة
    showroom_id = db.Column(db.Integer, db.ForeignKey('showrooms.id'), nullable=True)
    # nullable=True للمديرين العامين
    
    is_active = db.Column(db.Boolean, default=True)
    last_login = db.Column(db.DateTime)
    
    # العلاقات
    showroom = db.relationship('Showroom', back_populates='users')
```

#### 3. Customer (تعديل) - **مهم: عملاء مشتركون**
```python
class Customer(db.Model):
    # الحقول الموجودة
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    phone = db.Column(db.String(20))
    address = db.Column(db.String(200))
    
    # حقول جديدة
    email = db.Column(db.String(100))
    tax_id = db.Column(db.String(50))  # للشركات
    customer_type = db.Column(db.String(20), default='فرد')  # فرد، شركة
    notes = db.Column(db.Text)
    
    # ⚠️ لا نضيف showroom_id - العملاء مشتركون بين الصالات
    
    is_active = db.Column(db.Boolean, default=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # العلاقات
    orders = db.relationship('Order', back_populates='customer')
    
    # Index للبحث السريع
    __table_args__ = (
        db.Index('idx_customer_phone', 'phone'),
        db.Index('idx_customer_name', 'name'),
    )
```

#### 4. Order (تعديل) - **يسجل الصالة**
```python
class Order(db.Model):
    __tablename__ = 'orders'
    
    # الحقول الموجودة
    id = db.Column(db.Integer, primary_key=True)
    customer_id = db.Column(db.Integer, db.ForeignKey('customer.id'), nullable=False)
    order_date = db.Column(db.Date, nullable=False, default=datetime.utcnow)
    delivery_date = db.Column(db.Date)
    deadline = db.Column(db.Date)
    meters = db.Column(db.Integer, nullable=False)
    total_value = db.Column(db.Float, default=0.0)
    status = db.Column(db.String(50), default='مفتوح')
    received_by = db.Column(db.String(100))
    start_date = db.Column(db.Date)
    end_date = db.Column(db.Date)
    
    # حقول جديدة - مهمة
    showroom_id = db.Column(db.Integer, db.ForeignKey('showrooms.id'), nullable=False)
    # ✅ كل طلب مرتبط بصالة واحدة
    
    # العلاقات
    customer = db.relationship('Customer', back_populates='orders')
    showroom = db.relationship('Showroom', back_populates='orders')
    # ... باقي العلاقات الموجودة
    
    # Indexes للأداء
    __table_args__ = (
        db.Index('idx_showroom_status', 'showroom_id', 'status'),
        db.Index('idx_showroom_date', 'showroom_id', 'order_date'),
        db.Index('idx_customer_showroom', 'customer_id', 'showroom_id'),
    )
```

#### 5. Material (تعديل) - **مع سياسة التسعير**
```python
class Material(db.Model):
    # الحقول الموجودة
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    unit = db.Column(db.String(50), nullable=False)
    quantity_available = db.Column(db.Float, default=0)
    
    # تعديل حقول الأسعار - حل التعارض
    cost_price = db.Column(db.Float, default=0)  # سعر التكلفة (المحسوب)
    purchase_price = db.Column(db.Float, default=0)  # آخر سعر شراء
    selling_price = db.Column(db.Float, default=0)  # سعر البيع (اختياري)
    
    # سياسة التسعير
    cost_price_mode = db.Column(db.String(30), default='purchase_price_default')
    # القيم: purchase_price_default, weighted_average, last_invoice
    
    allow_manual_price_edit = db.Column(db.Boolean, default=True)
    price_locked = db.Column(db.Boolean, default=False)  # إذا عُدّل يدوياً
    price_updated_at = db.Column(db.DateTime, default=datetime.utcnow)
    price_updated_by = db.Column(db.String(100))
    
    # ربط بالصالة
    showroom_id = db.Column(db.Integer, db.ForeignKey('showrooms.id'), nullable=False)
    
    # Soft Delete
    is_active = db.Column(db.Boolean, default=True)
    deleted_at = db.Column(db.DateTime)
    
    # العلاقات
    showroom = db.relationship('Showroom', back_populates='materials')
    
    # Validators
    @validates('cost_price', 'purchase_price', 'selling_price')
    def validate_price(self, key, value):
        if value < 0:
            raise ValueError(f"{key} cannot be negative")
        return value
    
    @validates('quantity_available')
    def validate_quantity(self, key, value):
        if value < 0:
            raise ValueError("Quantity cannot be negative")
        return value
```

#### 6. جداول أخرى تحتاج showroom_id
- **Stage**: `showroom_id` (NOT NULL)
- **Document**: `showroom_id` (NOT NULL)
- **Payment**: `showroom_id` (NOT NULL) - تبقى باسمها (مدفوعات العملاء)
- **OrderCost**: `showroom_id` (NOT NULL)
- **MaterialConsumption**: `showroom_id` (NOT NULL)
- **OrderMaterial**: `showroom_id` (NOT NULL)
- **ReceivedOrder**: `showroom_id` (NOT NULL)

---

## الجزء الثاني: إدارة المورّدين والفواتير - محدث

### نماذج جديدة

#### 1. Supplier (جديد)
```python
class Supplier(db.Model):
    __tablename__ = 'suppliers'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    code = db.Column(db.String(20), unique=True)  # كود المورد
    phone = db.Column(db.String(20))
    email = db.Column(db.String(100))
    address = db.Column(db.String(200))
    tax_id = db.Column(db.String(50))
    contact_person = db.Column(db.String(100))
    payment_terms = db.Column(db.String(100))  # شروط الدفع
    notes = db.Column(db.Text)
    
    # ربط بالصالة
    showroom_id = db.Column(db.Integer, db.ForeignKey('showrooms.id'), nullable=False)
    
    # Soft Delete
    is_active = db.Column(db.Boolean, default=True)
    deleted_at = db.Column(db.DateTime)
    deleted_by = db.Column(db.String(100))
    
    # Timestamps
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
    created_by = db.Column(db.String(100))
    
    # العلاقات
    showroom = db.relationship('Showroom', back_populates='suppliers')
    invoices = db.relationship('PurchaseInvoice', back_populates='supplier')
    payments = db.relationship('SupplierPayment', back_populates='supplier')
    
    # Computed property
    @property
    def total_debt(self):
        """إجمالي الديون المتبقية"""
        total = 0
        for invoice in self.invoices:
            if invoice.status != 'paid':
                total += invoice.remaining_amount
        return total
```

#### 2. PurchaseInvoice (جديد) - **محسّن**
```python
class PurchaseInvoice(db.Model):
    __tablename__ = 'purchase_invoices'
    
    id = db.Column(db.Integer, primary_key=True)
    invoice_number = db.Column(db.String(50), unique=True, nullable=False)
    supplier_id = db.Column(db.Integer, db.ForeignKey('suppliers.id'), nullable=False)
    showroom_id = db.Column(db.Integer, db.ForeignKey('showrooms.id'), nullable=False)
    
    invoice_date = db.Column(db.Date, nullable=False, default=datetime.utcnow)
    due_date = db.Column(db.Date)
    
    # المبالغ
    total_amount = db.Column(db.Float, nullable=False, default=0)
    discount_amount = db.Column(db.Float, default=0)
    tax_amount = db.Column(db.Float, default=0)
    final_amount = db.Column(db.Float, nullable=False, default=0)
    
    # الحالة
    status = db.Column(db.String(20), default='open')
    # القيم: open, partial, paid, overdue, cancelled
    
    notes = db.Column(db.Text)
    
    # Soft Delete
    is_active = db.Column(db.Boolean, default=True)
    cancelled_at = db.Column(db.DateTime)
    cancelled_by = db.Column(db.String(100))
    cancellation_reason = db.Column(db.Text)
    
    # Timestamps
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    created_by = db.Column(db.String(100))
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
    
    # العلاقات
    supplier = db.relationship('Supplier', back_populates='invoices')
    showroom = db.relationship('Showroom')
    items = db.relationship('PurchaseInvoiceItem', back_populates='invoice', 
                           cascade='all, delete-orphan')
    payments = db.relationship('SupplierPayment', back_populates='invoice')
    
    # Computed properties - بدل حقول مكررة
    @property
    def paid_amount(self):
        """المبلغ المدفوع - محسوب من الدفعات"""
        return sum(p.amount for p in self.payments if p.is_active)
    
    @property
    def remaining_amount(self):
        """المبلغ المتبقي"""
        return self.final_amount - self.paid_amount
    
    # Indexes
    __table_args__ = (
        db.Index('idx_supplier_showroom', 'supplier_id', 'showroom_id'),
        db.Index('idx_invoice_date', 'invoice_date'),
        db.Index('idx_invoice_status', 'status'),
    )
```

#### 3. PurchaseInvoiceItem (جديد) - **محسّن**
```python
class PurchaseInvoiceItem(db.Model):
    __tablename__ = 'purchase_invoice_items'
    
    id = db.Column(db.Integer, primary_key=True)
    invoice_id = db.Column(db.Integer, db.ForeignKey('purchase_invoices.id'), nullable=False)
    material_id = db.Column(db.Integer, db.ForeignKey('material.id'), nullable=False)
    
    quantity = db.Column(db.Float, nullable=False)
    purchase_price = db.Column(db.Float, nullable=False)  # سعر الشراء للوحدة
    
    discount_percent = db.Column(db.Float, default=0)
    discount_amount = db.Column(db.Float, default=0)
    
    notes = db.Column(db.String(200))
    
    # العلاقات
    invoice = db.relationship('PurchaseInvoice', back_populates='items')
    material = db.relationship('Material')
    
    # Computed property - بدل حقل مخزن
    @property
    def line_total(self):
        """إجمالي السطر"""
        subtotal = self.quantity * self.purchase_price
        return subtotal - self.discount_amount
    
    # Validators
    @validates('quantity', 'purchase_price')
    def validate_positive(self, key, value):
        if value < 0:
            raise ValueError(f"{key} must be positive")
        return value
```

#### 4. SupplierPayment (جديد) - **محسّن**
```python
class SupplierPayment(db.Model):
    __tablename__ = 'supplier_payments'
    
    id = db.Column(db.Integer, primary_key=True)
    supplier_id = db.Column(db.Integer, db.ForeignKey('suppliers.id'), nullable=False)
    invoice_id = db.Column(db.Integer, db.ForeignKey('purchase_invoices.id'), nullable=False)
    # ✅ invoice_id required - supplier_id نحصل عليه من الفاتورة
    
    amount = db.Column(db.Float, nullable=False)
    payment_method = db.Column(db.String(50), default='نقد')
    # القيم: نقد، بنك، شيك، تحويل، آجل
    
    payment_date = db.Column(db.Date, nullable=False, default=datetime.utcnow)
    reference_number = db.Column(db.String(50))  # رقم المرجع/الشيك
    
    notes = db.Column(db.Text)
    paid_by = db.Column(db.String(100), nullable=False)  # الموظف الذي سجل الدفع
    
    # Soft Delete
    is_active = db.Column(db.Boolean, default=True)
    cancelled_at = db.Column(db.DateTime)
    cancelled_by = db.Column(db.String(100))
    
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # العلاقات
    supplier = db.relationship('Supplier', back_populates='payments')
    invoice = db.relationship('PurchaseInvoice', back_populates='payments')
    
    # Validators
    @validates('amount')
    def validate_amount(self, key, value):
        if value <= 0:
            raise ValueError("Payment amount must be positive")
        return value
```

### تدفق العمل - محدث
1. **إنشاء فاتورة شراء**:
   - إضافة رأس الفاتورة (supplier, date, etc)
   - إضافة عناصر الفاتورة (items)
   - حساب الإجماليات تلقائياً
   
2. **تحديث المخزون** (عند تفعيل الفاتورة):
   - لكل عنصر: `Material.quantity_available += quantity`
   - تحديث `Material.purchase_price = item.purchase_price`
   - حساب `Material.cost_price` وفق السياسة المختارة
   - تسجيل في Audit Log
   
3. **تسجيل الدفعات**:
   - إضافة دفعة مرتبطة بالفاتورة
   - حساب `paid_amount` و `remaining_amount` تلقائياً
   - تحديث `status` (open → partial → paid)
   
4. **التحذيرات التلقائية**:
   - تحديد الفواتير المتأخرة (due_date < today and status != 'paid')
   - تنبيهات انخفاض المخزون

---

## الجزء الثالث: سياسة تسعير التكلفة - محدث

### سياسات مدعومة
```python
class CostPricingMode:
    PURCHASE_DEFAULT = 'purchase_price_default'  # افتراضي - آخر سعر شراء
    WEIGHTED_AVERAGE = 'weighted_average'  # متوسط مرجّح
    LAST_INVOICE = 'last_invoice'  # آخر فاتورة
```

### منطق الحساب - مع Audit
```python
def update_material_cost_price(material, new_purchase_price, quantity, invoice_id):
    """
    تحديث سعر التكلفة وفق السياسة المختارة
    """
    old_price = material.cost_price
    old_qty = material.quantity_available
    
    # تحقق: هل السعر مقفل (معدّل يدوياً)؟
    if material.price_locked and not material.allow_manual_price_edit:
        # لا تحدث - السعر محمي
        return
    
    # طبّق السياسة
    if material.cost_price_mode == 'purchase_price_default':
        material.cost_price = new_purchase_price
    
    elif material.cost_price_mode == 'weighted_average':
        # متوسط مرجّح
        total_cost = (old_price * old_qty) + (new_purchase_price * quantity)
        total_qty = old_qty + quantity
        material.cost_price = total_cost / total_qty if total_qty > 0 else new_purchase_price
    
    elif material.cost_price_mode == 'last_invoice':
        material.cost_price = new_purchase_price
    
    # تسجيل آخر سعر شراء
    material.purchase_price = new_purchase_price
    material.price_updated_at = datetime.utcnow()
    material.price_updated_by = current_user.username
    
    # تسجيل في Audit Log
    log_price_change(
        table='material',
        record_id=material.id,
        field='cost_price',
        old_value=old_price,
        new_value=material.cost_price,
        reason=f'Updated from invoice {invoice_id}'
    )
```

### عناصر التحكم في أدوات المشرف
```python
class SystemSettings(db.Model):
    """إعدادات النظام المركزية"""
    __tablename__ = 'system_settings'
    
    id = db.Column(db.Integer, primary_key=True)
    key = db.Column(db.String(100), unique=True, nullable=False)
    value = db.Column(db.Text)
    value_type = db.Column(db.String(20), default='string')  # string, int, bool, json
    category = db.Column(db.String(50))  # pricing, permissions, general
    description = db.Column(db.String(200))
    
    showroom_id = db.Column(db.Integer, nullable=True)  # null = system-wide
    
    updated_at = db.Column(db.DateTime, onupdate=datetime.utcnow)
    updated_by = db.Column(db.String(100))

# أمثلة إعدادات:
# key='default_cost_price_mode', value='purchase_price_default', category='pricing'
# key='allow_manual_cost_edit_role_reception', value='false', category='permissions'
# key='low_stock_threshold', value='10', value_type='int', category='inventory'
```

---

## الجزء الرابع: صلاحيات وأذونات - محدث

### Helper Functions

```python
def get_scoped_query(model_class, user=None):
    """
    ترجع Query مصفّى حسب showroom_id للمستخدم
    """
    from flask import session
    user = user or current_user
    query = model_class.query
    
    # تحقق: هل النموذج يحتوي على showroom_id؟
    if not hasattr(model_class, 'showroom_id'):
        return query
    
    # المدير يرى حسب الفلتر المختار
    if user.role == 'مدير':
        showroom_filter = session.get('showroom_filter', 'all')
        if showroom_filter != 'all':
            query = query.filter_by(showroom_id=int(showroom_filter))
    
    # موظفون آخرون يرون صالتهم فقط
    elif user.showroom_id:
        query = query.filter_by(showroom_id=user.showroom_id)
    
    # تصفية Soft Delete
    if hasattr(model_class, 'is_active'):
        query = query.filter_by(is_active=True)
    
    return query

# استخدام:
# orders = get_scoped_query(Order).filter_by(status='مفتوح').all()
```

### Decorator للحماية
```python
from functools import wraps
from flask import flash, redirect, url_for, session

def require_showroom_access(f):
    """
    Decorator لحماية المسارات - يتأكد أن المستخدم له صلاحية الصالة
    """
    @wraps(f)
    def decorated_function(*args, **kwargs):
        showroom_id = kwargs.get('showroom_id')
        
        # المدير له صلاحية كل الصالات
        if current_user.role == 'مدير':
            return f(*args, **kwargs)
        
        # موظف بصالة محددة
        if current_user.showroom_id and current_user.showroom_id == int(showroom_id):
            return f(*args, **kwargs)
        
        flash('ليس لديك صلاحية للوصول إلى هذه الصالة', 'danger')
        return redirect(url_for('dashboard'))
    
    return decorated_function

# استخدام:
@app.route('/showroom/<int:showroom_id>/orders')
@login_required
@require_showroom_access
def showroom_orders(showroom_id):
    orders = get_scoped_query(Order).all()
    return render_template('orders.html', orders=orders)
```

### مصفوفة الصلاحيات
| الدور | العملاء | الطلبات | المواد | الموردين | الفواتير | الإعدادات |
|-------|---------|---------|--------|-----------|----------|-----------|
| **مدير** | عرض الكل | عرض/تعديل الكل | عرض/تعديل الكل | عرض/تعديل الكل | عرض/تعديل الكل | ✅ كامل |
| **موظف استقبال** | عرض الكل، إضافة | صالته فقط | عرض فقط | ❌ | ❌ | ❌ |
| **مسؤول مخزن** | عرض | عرض صالته | صالته فقط | صالته فقط | صالته فقط | ❌ |
| **مسؤول إنتاج** | عرض | صالته فقط | صالته (عرض) | ❌ | ❌ | ❌ |
| **مسؤول عمليات** | عرض الكل | صالته فقط | صالته فقط | صالته فقط | صالته (عرض) | محدود |

**ملاحظة مهمة**: 
- ✅ **العملاء مرئيون للجميع** (بحث شامل)
- ✅ لكن **الطلبات مقيدة بالصالة** (عزل تام)
- ✅ عند إنشاء طلب جديد، يُسجل `showroom_id` تلقائياً من المستخدم

---

## الجزء الخامس: Audit Log والتتبع - جديد

### نموذج AuditLog
```python
class AuditLog(db.Model):
    """سجل التدقيق لتتبع التغييرات المهمة"""
    __tablename__ = 'audit_logs'
    
    id = db.Column(db.Integer, primary_key=True)
    
    # ما الذي تغير؟
    table_name = db.Column(db.String(50), nullable=False)
    record_id = db.Column(db.Integer, nullable=False)
    action = db.Column(db.String(20), nullable=False)  # create, update, delete
    
    # تفاصيل التغيير
    field_name = db.Column(db.String(50))  # للـ update
    old_value = db.Column(db.Text)
    new_value = db.Column(db.Text)
    
    # من؟ متى؟ أين؟
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    user_name = db.Column(db.String(100))
    showroom_id = db.Column(db.Integer, db.ForeignKey('showrooms.id'))
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    ip_address = db.Column(db.String(50))
    
    # سبب التغيير (اختياري)
    reason = db.Column(db.Text)
    
    # Indexes
    __table_args__ = (
        db.Index('idx_audit_table_record', 'table_name', 'record_id'),
        db.Index('idx_audit_user', 'user_id'),
        db.Index('idx_audit_timestamp', 'timestamp'),
    )

def log_change(table, record_id, action, field=None, old_val=None, new_val=None, reason=None):
    """دالة مساعدة لتسجيل التغييرات"""
    log = AuditLog(
        table_name=table,
        record_id=record_id,
        action=action,
        field_name=field,
        old_value=str(old_val) if old_val else None,
        new_value=str(new_val) if new_val else None,
        user_id=current_user.id if current_user.is_authenticated else None,
        user_name=current_user.username if current_user.is_authenticated else 'system',
        showroom_id=current_user.showroom_id if current_user.is_authenticated else None,
        ip_address=request.remote_addr if request else None,
        reason=reason
    )
    db.session.add(log)
```

### متى نستخدم Audit Log؟
- ✅ تغييرات الأسعار (cost_price, purchase_price, selling_price)
- ✅ تغييرات الكميات (quantity_available)
- ✅ إلغاء الفواتير
- ✅ حذف السجلات المهمة
- ✅ تعديل الأذونات والصلاحيات

---

## الجزء السادس: تعديلات قاعدة البيانات - كاملة

### Migration 1: إنشاء Showroom وإضافة showroom_id
```python
# إنشاء جدول Showroom
op.create_table('showrooms', ...)

# إضافة showroom_id للجداول الموجودة
tables_to_update = [
    'user',  # nullable
    # 'customer',  # ❌ لا نضيف - عملاء مشتركون
    'orders', 'material', 'stage', 'document', 
    'payment', 'order_cost', 'material_consumption', 
    'order_material', 'received_order'
]

for table in tables_to_update:
    nullable = (table == 'user')  # المديرين بدون صالة
    op.add_column(table, 
        sa.Column('showroom_id', sa.Integer(), 
                  sa.ForeignKey('showrooms.id'), 
                  nullable=nullable)
    )

# إنشاء صالة افتراضية
op.execute("""
    INSERT INTO showrooms (name, code, is_active) 
    VALUES ('الصالة الرئيسية', 'MAIN', 1)
""")

# إسناد البيانات الحالية للصالة الافتراضية
for table in tables_to_update:
    if table != 'user':
        op.execute(f"UPDATE {table} SET showroom_id = 1")
```

### Migration 2: تعديل Material للتسعير
```python
# إضافة حقول التسعير الجديدة
op.add_column('material', sa.Column('cost_price', sa.Float(), default=0))
op.add_column('material', sa.Column('purchase_price', sa.Float(), default=0))
op.add_column('material', sa.Column('selling_price', sa.Float(), default=0))
op.add_column('material', sa.Column('cost_price_mode', sa.String(30), default='purchase_price_default'))
op.add_column('material', sa.Column('allow_manual_price_edit', sa.Boolean(), default=True))
op.add_column('material', sa.Column('price_locked', sa.Boolean(), default=False))
op.add_column('material', sa.Column('price_updated_by', sa.String(100)))

# نسخ البيانات القديمة
op.execute("UPDATE material SET cost_price = unit_price, purchase_price = unit_price")

# ملاحظة: يمكن الاحتفاظ بـ unit_price للتوافق أو حذفه لاحقاً
```

### Migration 3: الموردين والفواتير
```python
# إنشاء جداول الموردين
op.create_table('suppliers', ...)
op.create_table('purchase_invoices', ...)
op.create_table('purchase_invoice_items', ...)
op.create_table('supplier_payments', ...)

# Indexes
op.create_index('idx_supplier_showroom', 'suppliers', ['showroom_id'])
op.create_index('idx_invoice_date', 'purchase_invoices', ['invoice_date'])
op.create_index('idx_invoice_status', 'purchase_invoices', ['status'])
```

### Migration 4: Audit Log والإعدادات
```python
op.create_table('audit_logs', ...)
op.create_table('system_settings', ...)

# Indexes
op.create_index('idx_audit_table_record', 'audit_logs', ['table_name', 'record_id'])
op.create_index('idx_audit_timestamp', 'audit_logs', ['timestamp'])
```

---

## الجزء السابع: واجهات المستخدم - محدث

### 1. Navbar - Showroom Selector
```html
<!-- في base.html -->
{% if current_user.role == 'مدير' %}
<div class="showroom-selector">
    <label>الصالة:</label>
    <select id="showroom_filter" class="form-select">
        <option value="all">جميع الصالات</option>
        {% for showroom in showrooms %}
        <option value="{{ showroom.id }}" 
                {% if session.get('showroom_filter') == showroom.id %}selected{% endif %}>
            {{ showroom.name }}
        </option>
        {% endfor %}
    </select>
</div>
{% elif current_user.showroom %}
<div class="showroom-badge">
    <span class="badge bg-primary">{{ current_user.showroom.name }}</span>
</div>
{% endif %}
```

### 2. صفحة العملاء - مشتركة
```html
<!-- customers.html -->
<div class="card">
    <div class="card-header">
        <h5>قائمة العملاء (مشتركة بين الصالات)</h5>
        <small class="text-muted">يمكنك رؤية جميع العملاء من كل الصالات</small>
    </div>
    <div class="card-body">
        <table class="table">
            <thead>
                <tr>
                    <th>الاسم</th>
                    <th>الهاتف</th>
                    <th>عدد الطلبات</th>
                    <th>آخر طلب في</th>
                    <th>الإجراءات</th>
                </tr>
            </thead>
            <tbody>
                {% for customer in customers %}
                <tr>
                    <td>{{ customer.name }}</td>
                    <td>{{ customer.phone }}</td>
                    <td>{{ customer.orders|length }}</td>
                    <td>
                        {% set last_order = customer.orders|selectattr("showroom_id", "equalto", current_user.showroom_id)|first %}
                        {{ last_order.order_date if last_order else '-' }}
                    </td>
                    <td>
                        <a href="{{ url_for('customer_detail', customer_id=customer.id) }}">
                            عرض
                        </a>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</div>
```

### 3. صفحة الطلبات - مصفاة بالصالة
```python
@app.route('/orders')
@login_required
def orders():
    # استخدام Helper للتصفية التلقائية
    orders = get_scoped_query(Order).order_by(Order.order_date.desc()).all()
    return render_template('orders.html', orders=orders)
```

### 4. صفحات الموردين
```html
<!-- suppliers.html -->
<a href="{{ url_for('new_supplier') }}" class="btn btn-primary">
    <i class="fas fa-plus"></i> إضافة مورد جديد
</a>

<!-- purchase_invoices.html -->
<a href="{{ url_for('new_purchase_invoice') }}" class="btn btn-success">
    <i class="fas fa-file-invoice"></i> فاتورة شراء جديدة
</a>
```

### 5. صفحة إعدادات أدوات المشرف
```html
<!-- admin_settings.html -->
<div class="card">
    <div class="card-header">
        <h5>إعدادات سياسة التسعير</h5>
    </div>
    <div class="card-body">
        <form method="POST">
            <div class="mb-3">
                <label>السياسة الافتراضية:</label>
                <select name="default_cost_price_mode" class="form-select">
                    <option value="purchase_price_default">آخر سعر شراء (افتراضي)</option>
                    <option value="weighted_average">متوسط مرجّح</option>
                    <option value="last_invoice">آخر فاتورة</option>
                </select>
            </div>
            
            <div class="mb-3">
                <label>
                    <input type="checkbox" name="allow_manual_edit_reception"> 
                    السماح لموظفي الاستقبال بتعديل الأسعار
                </label>
            </div>
            
            <button type="submit" class="btn btn-primary">حفظ الإعدادات</button>
        </form>
    </div>
</div>

<!-- Materials Pricing Policy -->
<div class="card mt-3">
    <div class="card-header">
        <h5>سياسة تسعير الأصناف</h5>
    </div>
    <div class="card-body">
        <table class="table">
            <thead>
                <tr>
                    <th>المادة</th>
                    <th>السياسة الحالية</th>
                    <th>سعر التكلفة</th>
                    <th>قفل السعر</th>
                    <th>تعديل</th>
                </tr>
            </thead>
            <tbody>
                {% for material in materials %}
                <tr>
                    <td>{{ material.name }}</td>
                    <td>{{ material.cost_price_mode }}</td>
                    <td>{{ material.cost_price }}</td>
                    <td>
                        <i class="fas fa-{{ 'lock' if material.price_locked else 'lock-open' }}"></i>
                    </td>
                    <td>
                        <button class="btn btn-sm btn-warning" 
                                onclick="editMaterialPolicy({{ material.id }})">
                            تعديل
                        </button>
                    </td>
                </tr>
                {% endfor %}
            </tbody>
        </table>
    </div>
</div>
```

---

## الجزء الثامن: خطة الترحيل والتنفيذ - مفصلة

### المرحلة 1: تحضير وتنظيف (أسبوع 1)
**الأهداف**: تنظيف الكود وإعداد البيئة

1. ✅ تنظيف إشارات `ProductionStage` القديمة
2. ✅ إعادة تسمية `Material.unit_price` → `cost_price` (أو إضافة حقول منفصلة)
3. ✅ إضافة Validators للنماذج الحالية
4. ✅ كتابة Unit Tests للوظائف الحالية
5. ✅ نسخة احتياطية كاملة من قاعدة البيانات

**المخرجات**:
- كود نظيف بدون تعارضات
- Suite اختبار أساسي
- نسخة احتياطية آمنة

---

### المرحلة 2: إضافة Showroom والعزل (أسبوع 2)
**الأهداف**: تطبيق فصل الصالات

**الخطوات**:
1. إنشاء نموذج `Showroom`
2. Migration لإضافة `showroom_id` للجداول (عدا Customer)
3. إنشاء صالة افتراضية وإسناد البيانات
4. تحديث `User` model
5. كتابة Helpers: `get_scoped_query()`, `@require_showroom_access`
6. تحديث جميع المسارات لاستخدام Helpers
7. إضافة Showroom Selector في Navbar
8. اختبارات العزل

**المخرجات**:
- عزل كامل بين الصالات
- موظفون يرون صالتهم فقط
- مديرون يمكنهم التبديل بين الصالات

---

### المرحلة 3: الموردين والفواتير (أسبوع 3-4)
**الأهداف**: إضافة منظومة الموردين

**الخطوات**:
1. إنشاء نماذج: Supplier, PurchaseInvoice, PurchaseInvoiceItem, SupplierPayment
2. Migration للجداول الجديدة
3. CRUD للموردين:
   - قائمة الموردين
   - إضافة/تعديل/حذف (soft delete)
4. فواتير الشراء:
   - إنشاء فاتورة مع عناصرها
   - عرض تفاصيل الفاتورة
   - تحديث المخزون عند التفعيل
5. دفعات الموردين:
   - تسجيل دفعة
   - حساب المتبقي
   - تحديث حالة الفاتورة
6. تقارير:
   - ديون الموردين
   - فواتير متأخرة
7. اختبارات التدفق الكامل

**المخرجات**:
- نظام موردين كامل
- تكامل مع المخزون
- تقارير الديون

---

### المرحلة 4: سياسات التسعير (أسبوع 5)
**الأهداف**: تطبيق التسعير الذكي

**الخطوات**:
1. إنشاء `SystemSettings` model
2. تحديث `Material` بحقول التسعير
3. تطبيق منطق الحساب:
   ```python
   def apply_cost_pricing_policy(material, invoice_item):
       # ...
   ```
4. صفحة إعدادات التسعير في أدوات المشرف
5. واجهة إدارة سياسات الأصناف
6. Audit Log للأسعار
7. اختبارات السياسات المختلفة

**المخرجات**:
- تسعير تلقائي حسب السياسة
- إمكانية التخصيص لكل صنف
- تتبع تغييرات الأسعار

---

### المرحلة 5: Audit Log والتتبع (أسبوع 6)
**الأهداف**: تتبع شامل للتغييرات

**الخطوات**:
1. إنشاء `AuditLog` model
2. دالة `log_change()` helper
3. تطبيق Logging على:
   - تغييرات الأسعار
   - تغييرات الكميات
   - حذف/إلغاء السجلات
4. صفحة عرض سجل التدقيق
5. فلاتر وبحث في السجل
6. تقرير نشاطات المستخدمين

**المخرجات**:
- تتبع كامل للتغييرات المهمة
- محاسبة ومراجعة
- أمان وشفافية

---

### المرحلة 6: الواجهات والتحسينات (أسبوع 7)
**الأهداف**: تحسين UX وإضافة تقارير

**الخطوات**:
1. تحسين Navbar والتنقل
2. تحسين صفحات العملاء (مشتركة)
3. Dashboard بإحصائيات حسب الصالة
4. تقارير متقدمة:
   - ربحية الصالات
   - دوران المخزون
   - أداء الموردين
5. تصدير CSV/PDF
6. تحسينات UX العامة
7. توثيق المستخدم

**المخرجات**:
- واجهات سلسة وسهلة
- تقارير شاملة
- تصدير البيانات

---

## الجزء التاسع: المخاطر والتحديات - محدث

### ⚠️ خطر 1: هجرة البيانات
**التخفيف**:
- ✅ 3 نسخ احتياطية: قبل، أثناء، بعد
- ✅ اختبار Migrations في بيئة تطوير
- ✅ Rollback scripts جاهزة
- ✅ خطة طوارئ

### ⚠️ خطر 2: الأداء
**التخفيف**:
- ✅ Indexes مناسبة على showroom_id
- ✅ Pagination للقوائم الطويلة
- ✅ Caching للإعدادات
- ✅ Query optimization

### ⚠️ خطر 3: تعقيد الصلاحيات
**التخفيف**:
- ✅ Helpers موحدة
- ✅ Decorators واضحة
- ✅ توثيق شامل
- ✅ Testing مكثف

### ⚠️ خطر 4: تدريب المستخدمين
**التخفيف**:
- ✅ دليل مستخدم مصور
- ✅ فيديوهات تدريبية
- ✅ جلسات تدريب
- ✅ دعم فني

---

## الجزء العاشر: ملخص التغييرات الرئيسية

### ✨ ما الجديد في هذه النسخة؟

1. **العملاء مشتركون**: 
   - ✅ لا يوجد `showroom_id` في Customer
   - ✅ يمكن رؤيتهم من جميع الصالات
   - ✅ الطلبات فقط مرتبطة بالصالة

2. **تسعير محسّن**:
   - ✅ فصل `cost_price` و `purchase_price`
   - ✅ ثلاث سياسات تسعير
   - ✅ Audit trail للأسعار
   - ✅ قفل الأسعار المعدلة يدوياً

3. **موردين محسّنون**:
   - ✅ Computed properties بدل حقول مكررة
   - ✅ Soft delete لحماية البيانات
   - ✅ Validators لمنع البيانات غير الصحيحة
   - ✅ علاقات واضحة

4. **صلاحيات دقيقة**:
   - ✅ Helpers موحدة (`get_scoped_query`)
   - ✅ Decorators للحماية
   - ✅ مصفوفة صلاحيات واضحة
   - ✅ عزل تام بين الصالات

5. **Audit وتتبع**:
   - ✅ نموذج AuditLog شامل
   - ✅ تسجيل تلقائي للتغييرات المهمة
   - ✅ تقارير النشاطات
   - ✅ محاسبة ومراجعة

6. **إعدادات مركزية**:
   - ✅ SystemSettings model
   - ✅ واجهة أدوات المشرف
   - ✅ تخصيص لكل صالة
   - ✅ Overrides للأصناف الفردية

---

## الأسئلة المتبقية للمستخدم

قبل البدء في التنفيذ، نحتاج قراراتك في:

1. **إعادة تسمية unit_price**:
   - الخيار A: إعادة تسمية `unit_price` → `cost_price` مع Migration
   - الخيار B: إضافة `cost_price` جديد والإبقاء على `unit_price` للتوافق
   - **التوصية**: الخيار B

2. **Audit Log**:
   - هل نطبقه من البداية أم في مرحلة لاحقة؟
   - **التوصية**: من البداية (مهم للأسعار)

3. **سياسة التسعير الافتراضية**:
   - أي سياسة تفضل كافتراضي؟
   - **التوصية**: `purchase_price_default` (الأبسط)

4. **الموردين**:
   - هل كل صالة لها موردون منفصلون، أم موردون مشتركون؟
   - **التوصية**: منفصلون (عزل كامل)

5. **الوقت المتاح**:
   - هل لديك 7-8 أسابيع للتطبيق الكامل؟
   - أم نبدأ بـ MVP (4 أسابيع) ثم نضيف تدريجياً؟
   - **التوصية**: MVP ثم توسع

---

## جاهز للتنفيذ! 🚀

الخطة الآن:
- ✅ شاملة ومفصلة
- ✅ محلولة من التعارضات
- ✅ مع تحسينات مقترحة
- ✅ مع خطة تنفيذ واضحة
- ✅ مع مراعاة المخاطر

**انتظر موافقتك للبدء!** 🎯

