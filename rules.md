# قواعد التطوير - نظام إدارة مصنع المطابخ

## القواعد الأساسية

### 1. قاعدة الملف الواحد للمسارات (Single Source of Truth)
- **المشكلة**: كان يوجد `app.py` و `app_part1.py` إلى `app_part4.py` مع تعريفات متضاربة
- **القاعدة**: 
  - ملف واحد فقط يحتوي على جميع المسارات والنماذج (`app.py`)
  - لا توجد ملفات مسارات منفصلة أو مكررة
  - جميع الـ API endpoints يجب أن تكون خارج كتلة `if __name__ == '__main__':`

### 2. قاعدة توحيد قاعدة البيانات (Database Consistency)
- **المشكلة**: تضارب في مسارات قاعدة البيانات بين `kitchen_factory.db` و `instance/kitchen_factory.db`
- **القاعدة**:
  - مسار واحد ثابت لقاعدة البيانات في جميع السكربتات
  - استخدام Alembic للمهاجرات بدلاً من SQL يدوي
  - تجنب كلمة `order` كاسم جدول (استخدم `orders`)
  - جميع السكربتات يجب أن تستخدم نفس `SQLALCHEMY_DATABASE_URI`

### 3. قاعدة التحقق من الصلاحيات والبيانات (Input Validation & Security)
- **المشكلة**: عدم وجود CSRF protection، أذونات غير متسقة، تحقق ضعيف من المدخلات
- **القاعدة**:
  - جميع النماذج POST يجب أن تحتوي على CSRF tokens
  - التحقق من الصلاحيات في كل مسار حساس
  - التحقق من صحة البيانات المدخلة (الأرقام، التواريخ، الملفات)
  - تقييد أنواع الملفات المرفوعة على مستوى السيرفر

## قواعد التتبع والتوثيق

### 1. تسجيل التغييرات في Change log.md
**الهدف**: تتبع جميع التعديلات بطريقة سهلة ومفصلة للمستخدم

**المتطلبات**:
- **تاريخ التغيير**: يجب تسجيل التاريخ بالصيغة `YYYY-MM-DD`
- **الملفات المعدلة**: قائمة بجميع الملفات التي تم تعديلها
- **أرقام السطور**: تحديد السطور المضافة أو المعدلة
- **وصف التغيير**: شرح واضح للهدف من التغيير
- **التأثير**: وصف تأثير التغيير على التطبيق

**الاستثناءات** (لا تُسجل في Change log):
- ❌ **ملفات Markdown (.md)**: جميع ملفات التوثيق والخطط لا تحتاج تسجيل في Change log
- ❌ **ملفات README**: تحديثات التوثيق العامة
- ❌ **ملفات .gitignore**: تغييرات إعدادات Git

**صيغة التتبع**:
```markdown
## [التاريخ] - وصف مختصر للتغيير
**الملفات**: 
- `ملف1.py` (السطور X-Y): وصف التغيير
- `ملف2.html` (السطر Z): وصف التغيير

**الهدف**: شرح الهدف من التغيير
**التأثير**: وصف تأثير التغيير على التطبيق
```

### 2. التأكد من التوافق وعدم التكرار
**الهدف**: ضمان استقرار التطبيق وتجنب التعارضات

**المتطلبات**:
- **فحص التوافق**: قبل أي تعديل، تأكد من توافق التغيير مع باقي أجزاء التطبيق
- **منع التكرار**: التحقق من عدم وجود تعريفات مكررة للمسارات أو النماذج
- **اختبار الوظائف**: التأكد من عمل جميع الوظائف المرتبطة بالتغيير
- **فحص القوالب**: التأكد من توافق القوالب مع النماذج والمسارات المعدلة

**خطوات التحقق**:
1. فحص جميع الملفات بحثاً عن التكرار
2. اختبار المسارات المتأثرة
3. التحقق من صحة القوالب
4. التأكد من عمل قاعدة البيانات
5. اختبار الصلاحيات والأذونات

## قواعد إضافية

### 4. قاعدة أمان الملفات
- التحقق من أنواع الملفات المرفوعة
- تنظيف أسماء الملفات قبل الحفظ
- تقييد حجم الملفات المرفوعة
- إنشاء مجلدات فرعية لكل طلب في `uploads/`

### 5. قاعدة معالجة الأخطاء
- استخدام try-catch blocks في العمليات الحساسة
- تسجيل الأخطاء بشكل واضح
- إظهار رسائل خطأ مفهومة للمستخدم
- استخدام db.session.rollback() في حالة الأخطاء

### 6. قاعدة توحيد التواريخ
- استخدام UTC في قاعدة البيانات
- توحيد صيغة التاريخ في جميع أنحاء التطبيق
- استخدام datetime.utcnow() بدلاً من datetime.now()

### 7. قاعدة الإعدادات الإقليمية (Localization)
**الهدف**: توحيد الإعدادات الإقليمية لتتناسب مع منطقة العمل (ليبيا)

**المتطلبات الأساسية**:

#### أ) العملة 💰
- **العملة الافتراضية**: الدينار الليبي (LYD)
- **الرمز**: `د.ل` أو `LYD`
- **التنسيق**: `1,234.56 دينار ليبي`
- **في الكود**: استخدام `دينار ليبي` في جميع العروض
- **في قاعدة البيانات**: تخزين الأرقام كـ `DECIMAL` أو `FLOAT`

#### ب) اللغة 🗣️
- **اللغة الافتراضية**: العربية (ar)
- **اتجاه النص**: من اليمين إلى اليسار (RTL)
- **الترميز**: UTF-8
- **في القوالب**: استخدام `lang="ar" dir="rtl"`
- **التسميات**: جميع النصوص بالعربية

#### ج) التوقيت الزمني ⏰
- **المنطقة الزمنية**: Africa/Tripoli (UTC+2)
- **التخزين**: UTC في قاعدة البيانات
- **العرض**: تحويل إلى التوقيت المحلي الليبي عند العرض
- **التنسيق**: `YYYY-MM-DD` أو `DD/MM/YYYY`

#### د) التنسيقات الأخرى 📋
- **أرقام الهواتف**: تنسيق ليبي (+218)
  - مثال: `+218 91 234 5678` أو `091-234-5678`
- **العناوين**: تنسيق العناوين الليبية
  - مثال: `المدينة، المنطقة، الشارع`
- **الأسماء**: دعم الأسماء العربية الكاملة

#### هـ) التطبيق في الكود 💻

**في النماذج (Models)**:
```python
# مثال: حقل السعر
price = db.Column(db.Float, nullable=False)  # يُخزن كرقم
# العرض: "1234.56 دينار ليبي"
```

**في القوالب (Templates)**:
```html
<!-- العملة -->
<span>{{ "%.2f"|format(order.total_price) }} دينار ليبي</span>

<!-- التاريخ -->
<span>{{ order.order_date.strftime('%Y-%m-%d') }}</span>

<!-- الهاتف -->
<span dir="ltr">{{ customer.phone }}</span>
```

**في المسارات (Routes)**:
```python
# استخدام timezone-aware datetime
from datetime import datetime, timezone

# عند الحفظ
order.order_date = datetime.now(timezone.utc)

# عند العرض (تحويل اختياري للتوقيت المحلي)
# يمكن إضافة helper function للتحويل
```

#### و) الفوائد ✅
- **تجربة مستخدم محلية**: واجهة مألوفة للمستخدمين الليبيين
- **دقة البيانات**: تنسيقات صحيحة للعملة والتواريخ
- **سهولة الصيانة**: إعدادات موحدة في كل التطبيق
- **التوسع المستقبلي**: سهولة إضافة لغات/عملات أخرى لاحقاً

#### ز) ملاحظات مهمة ⚠️
- **لا تخلط** بين التخزين (UTC/أرقام) والعرض (محلي/منسق)
- **استخدم** مكتبات مثل `Babel` أو `pytz` للتعامل مع المناطق الزمنية
- **اختبر** التنسيقات على بيانات حقيقية ليبية
- **وثّق** أي استثناءات أو حالات خاصة

### 8. قاعدة تنظيم ملفات التوثيق والخطط
**الهدف**: تنظيم ملفات Markdown في مكان محدد

**المتطلبات**:
- **ملفات Markdown الجديدة**: يجب وضعها في مجلد `اقتراحات تعديل/`
- **الاستثناءات** (تبقى في الجذر):
  - ✅ `Change log.md` - سجل التغييرات الرسمي
  - ✅ `rules.md` - قواعد التطوير
  - ✅ `README.md` - التوثيق الرئيسي
  - ✅ `database_schema.md` - توثيق قاعدة البيانات

**أنواع الملفات التي توضع في `اقتراحات تعديل/`**:
- 📋 خطط التطوير والميزات الجديدة
- 📊 تقارير المراجعة والتحليل
- 💡 مقترحات التحسين والتعديل
- 📝 ملاحظات ودراسات الجدوى
- 🔍 تقارير الأخطاء المفصلة

**الفائدة**:
- تنظيم أفضل للمشروع
- سهولة الوصول للخطط والمقترحات
- فصل التوثيق الرسمي عن الخطط المؤقتة

### 9. قاعدة تنظيف الملفات المؤقتة والتجريبية
**الهدف**: الحفاظ على المشروع نظيفاً ومنظماً

**المتطلبات**:
- **حذف السكربتات المؤقتة**: بعد الانتهاء من تنفيذها ونجاحها
- **حذف ملفات الاختبار**: Scripts تجريبية لم تعد مستخدمة
- **حذف النسخ الاحتياطية القديمة**: بعد التأكد من استقرار النظام

**أمثلة على الملفات التي يجب حذفها**:
- ❌ سكربتات migration مؤقتة بعد نجاح الترحيل
- ❌ سكربتات init/test بعد إنشاء البيانات الأولية
- ❌ ملفات `*.backup_*` القديمة (أكثر من 30 يوم)
- ❌ سكربتات `test_*.py` بعد نجاح الاختبارات
- ❌ ملفات `.pyc` و `__pycache__/`

**الاستثناءات** (تبقى):
- ✅ Migration scripts الرئيسية (للتوثيق)
- ✅ سكربتات الإعداد الأولية المهمة
- ✅ أحدث نسخة احتياطية

**متى تحذف**:
1. بعد التأكد من نجاح العملية
2. بعد اختبار النظام بشكل كامل
3. بعد الاحتفاظ بنسخة في Git/Version Control

**كيفية الحذف الآمن**:
```bash
# مثال: حذف سكربت بعد نجاحه
# 1. تأكد من نجاح السكربت
# 2. احتفظ بنسخة في Git
# 3. احذف الملف المؤقت
rm temp_migration_script.py
```

**الفائدة**:
- مشروع أنظف وأسهل للتصفح
- تقليل الارتباك والملفات المكررة
- تحسين الأداء (ملفات أقل)
- سهولة الصيانة والتطوير

### 10. قاعدة التعديل على ملف rules.md
**الهدف**: حماية ملف القواعد من التعديلات غير المقصودة

**القاعدة**:
- ⚠️ **لا تقم بالتعديل على هذا الملف (`rules.md`) إلا بأمر مباشر وصريح من المستخدم**
- ✅ يُسمح بالقراءة والاطلاع فقط
- ✅ التعديلات تتم فقط عند طلب المستخدم صراحةً
- ❌ لا تضف قواعد جديدة تلقائياً
- ❌ لا تحذف أو تعدل قواعد موجودة بدون أمر مباشر

**السبب**:
- ملف `rules.md` يحتوي على القواعد الأساسية للمشروع
- التعديلات العشوائية قد تؤثر على سير العمل
- يجب أن تكون التعديلات مدروسة ومقصودة

**الاستثناءات**:
- تصحيح أخطاء إملائية واضحة (بعد إعلام المستخدم)
- إضافة أمثلة توضيحية (بعد موافقة المستخدم)

### 11. قاعدة إنشاء ملفات Markdown
**الهدف**: منع إنشاء ملفات توثيق غير ضرورية أو غير مطلوبة

**القاعدة**:
- ⚠️ **لا تقم بإنشاء أي ملفات Markdown (.md) جديدة إلا بعد سؤال المستخدم والحصول على موافقته**
- ❌ لا تنشئ ملفات تقارير أو ملخصات تلقائياً
- ❌ لا تنشئ ملفات توثيق أو خطط بدون طلب صريح
- ✅ اسأل المستخدم أولاً عن الحاجة للملف وموقعه واسمه

**الاستثناءات** (يُسمح بإنشائها بدون سؤال):
- لا يوجد - يجب السؤال في جميع الحالات

**السبب**:
- تجنب تراكم ملفات التوثيق غير المطلوبة
- إعطاء المستخدم التحكم الكامل في هيكلة المشروع
- تقليل الفوضى في المجلدات
- احترام تفضيلات المستخدم في التوثيق

**عند الحاجة لإنشاء ملف**:
1. أخبر المستخدم بالحاجة لإنشاء ملف
2. اقترح اسم الملف وموقعه
3. اشرح محتوى الملف المقترح
4. انتظر موافقة المستخدم
5. أنشئ الملف فقط بعد الموافقة الصريحة

### 12. قاعدة تحديث توثيق قاعدة البيانات (Database Schema Documentation)
**الهدف**: ضمان تطابق التوثيق مع البنية الفعلية لقاعدة البيانات

#### القاعدة الأساسية ⚠️
**عند أي تعديل على قاعدة البيانات، يجب تحديث ملف `database_schema.md` فوراً**

#### متى يجب التحديث؟ 📝

يجب تحديث `database_schema.md` في الحالات التالية:

1. **إضافة جدول جديد**
   - إضافة قسم كامل للجدول الجديد
   - توثيق جميع الحقول والعلاقات
   - تحديث عدد الجداول في "نظرة عامة"

2. **تعديل جدول موجود**
   - إضافة/حذف/تعديل حقول
   - تغيير نوع البيانات
   - إضافة/تعديل فهارس (Indexes)
   - تعديل العلاقات (Relationships)

3. **إضافة خصائص محسوبة (@property)**
   - توثيق الخاصية المحسوبة
   - شرح كيفية حسابها
   - ذكر استخداماتها

4. **تعديل علاقات بين الجداول**
   - تحديث قسم "العلاقات"
   - تحديث الرسوم التوضيحية إن وجدت

#### ماذا يجب توثيقه؟ 📋

**لكل جدول يجب توثيق:**
- ✅ اسم الجدول (`__tablename__`)
- ✅ الوظيفة والغرض
- ✅ جميع الحقول مع النوع والقيود
- ✅ القيم الافتراضية (Default values)
- ✅ العلاقات مع الجداول الأخرى
- ✅ الفهارس (Indexes) إن وجدت
- ✅ الخصائص المحسوبة (@property)
- ✅ القيود والتحققات (Constraints/Validators)

#### صيغة التوثيق القياسية 📄

```markdown
## X. جدول [الاسم العربي] ([الاسم الإنجليزي])

### الوظيفة
وصف مختصر لوظيفة الجدول

### الحقول
| اسم الحقل | النوع | وصف | ملاحظات |
|-----------|-------|------|---------|
| `id` | Integer | المعرف الفريد | Primary Key |
| ... | ... | ... | ... |

### الخصائص المحسوبة (إن وجدت)
- `property_name`: وصف الخاصية وكيفية حسابها

### العلاقات
- **نوع العلاقة** مع `JدولAخر`: وصف العلاقة

### الفهارس (إن وجدت)
- `index_name`: وصف الفهرس
```

#### أمثلة على التحديثات 💡

**مثال 1: إضافة حقل جديد**
```python
# في app.py - إضافة حقل:
class Order(db.Model):
    is_archived = db.Column(db.Boolean, default=False)

# في database_schema.md - يجب إضافة:
| `is_archived` | Boolean | هل الطلبية مؤرشفة؟ | Default: False |
```

**مثال 2: إضافة جدول جديد**
```python
# في app.py:
class Technician(db.Model):
    __tablename__ = 'technicians'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)

# في database_schema.md - يجب إضافة قسم كامل:
## 19. جدول الفنيين (Technician)
### الوظيفة: ...
### الحقول: ...
```

#### الاستثناءات ❌

**لا يحتاج توثيق في database_schema.md:**
- جداول مؤقتة للاختبار
- جداول في ملفات migration فقط (ليست في Models)
- تعديلات في Helper Functions (ليست جداول)

#### التحقق قبل الالتزام (Commit) ✅

قبل عمل commit لأي تغيير في قاعدة البيانات:

- [ ] ✅ تم تحديث النماذج في `app.py`
- [ ] ✅ تم تحديث `database_schema.md`
- [ ] ✅ تم تحديث عدد الجداول في "نظرة عامة"
- [ ] ✅ تم التحقق من صحة التوثيق
- [ ] ✅ تم تحديث `Change log.md` (حسب القاعدة #1)

#### الفوائد 🎯

- ✅ **توثيق دائم محدّث**: المطورون الجدد يفهمون البنية بسرعة
- ✅ **تقليل الأخطاء**: معرفة البنية الدقيقة تمنع الأخطاء
- ✅ **سهولة الصيانة**: فهم العلاقات يسهل التطوير
- ✅ **مرجع موثوق**: بدلاً من قراءة الكود في كل مرة

#### ملاحظة مهمة ⚠️

- التوثيق في `database_schema.md` **ليس بديلاً** عن التعليقات في الكود
- يجب أن يكون الملف **مرجعاً شاملاً** وليس مختصراً
- عند الشك، **وثّق أكثر** بدلاً من أقل

---

### 13. قاعدة توحيد أسماء الجداول والفهارس (Table & Index Naming Consistency)
**الهدف**: منع تضارب أسماء الجداول والفهارس بين النماذج (Models) وقاعدة البيانات الفعلية

#### أ) المشكلة الشائعة 🔴
```python
# في Model:
class OrderMaterial(db.Model):
    __tablename__ = 'order_materials'  # ❌ اسم مختلف
    __table_args__ = (
        db.Index('idx_material_order', ...),  # ❌ موجود مسبقاً
    )

# في قاعدة البيانات الفعلية:
# اسم الجدول: 'order_material'  # ⚠️ تضارب!
# الفهرس موجود بالفعل من migration script
```

**النتيجة**: 
```
sqlite3.OperationalError: index idx_material_order already exists
```

#### ب) القواعد الأساسية ✅

##### 1. التحقق من اسم الجدول الفعلي قبل كتابة `__tablename__`
```bash
# خطوة 1: افحص قاعدة البيانات أولاً
sqlite3 database.db ".tables"
# أو
sqlite3 database.db "SELECT name FROM sqlite_master WHERE type='table';"

# خطوة 2: استخدم الاسم الموجود بالضبط
```

```python
# ✅ صحيح - تطابق تام
class OrderMaterial(db.Model):
    __tablename__ = 'order_material'  # نفس اسم الجدول في DB
```

##### 2. عدم تعريف فهارس موجودة مسبقاً
```python
# ❌ خطأ - إذا كانت الفهارس موجودة من migration
__table_args__ = (
    db.Index('idx_order_material', 'order_id', 'material_id'),
    db.Index('idx_material_order', 'material_id', 'order_id'),
)

# ✅ صحيح - احذف __table_args__ إذا أُنشئت الفهارس عبر migration
# أو استخدم:
__table_args__ = (
    db.Index('idx_order_material', 'order_id', 'material_id', 
             sqlite_where=None),  # مع خيارات إضافية فقط
)
```

##### 3. استخدام `IF NOT EXISTS` في migration scripts
```python
# في migration script
cursor.execute("""
    CREATE INDEX IF NOT EXISTS idx_material_order 
    ON order_material (material_id, order_id)
""")
```

##### 4. فصل المسؤوليات
- **Migration Scripts**: مسؤولة عن إنشاء الجداول والفهارس
- **Models**: تُعرّف البنية فقط، لا تُنشئ فهارس موجودة

#### ج) خطوات التحقق قبل التشغيل 🔍

**قبل تشغيل `app.py` أو `db.create_all()`:**

1️⃣ **افحص قاعدة البيانات**
```python
# سكربت فحص سريع
import sqlite3
conn = sqlite3.connect('database.db')
cursor = conn.cursor()

# أسماء الجداول
cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
tables = cursor.fetchall()
print("الجداول:", tables)

# فهارس جدول معين
cursor.execute("PRAGMA index_list('order_material')")
indexes = cursor.fetchall()
print("الفهارس:", indexes)

conn.close()
```

2️⃣ **قارن مع Models**
```python
# تأكد من تطابق:
# ✅ اسم الجدول في __tablename__
# ✅ أسماء الفهارس (إن وُجدت)
# ✅ أسماء الأعمدة
```

3️⃣ **اختبر في بيئة تطوير أولاً**
```bash
# نسخ احتياطية قبل التشغيل
cp database.db database.db.backup
python app.py  # اختبر
```

#### د) قواعد التسمية الموحدة 📝

##### أسماء الجداول:
```python
# ✅ النمط الموصى به:
# - جمع للكيانات: users, orders, materials
# - مفرد للعلاقات: order_material (ليس order_materials)
# - snake_case دائماً
# - بالإنجليزية (تجنب الأحرف الخاصة)

class User(db.Model):
    __tablename__ = 'users'  # جمع

class OrderMaterial(db.Model):
    __tablename__ = 'order_material'  # مفرد للجدول الرابط
```

##### أسماء الفهارس:
```python
# ✅ النمط الموصى به:
# idx_<table>_<columns>
# مثال:
- idx_users_email
- idx_orders_customer_id
- idx_order_material_order_id
- idx_om_status  # اختصار مقبول

# ❌ تجنب:
- index1, index2  # غير واضح
- UserEmailIndex  # CamelCase
- idx_order_materials  # تضارب في اسم الجدول
```

#### هـ) استراتيجية الترحيل (Migration Strategy) 🔄

##### عند إنشاء جدول جديد:
```python
# 1️⃣ أنشئ migration script أولاً
def create_new_table():
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS order_material (
            id INTEGER PRIMARY KEY,
            order_id INTEGER NOT NULL,
            material_id INTEGER NOT NULL,
            ...
        )
    """)
    
    # أنشئ الفهارس
    cursor.execute("""
        CREATE INDEX IF NOT EXISTS idx_order_material 
        ON order_material (order_id, material_id)
    """)

# 2️⃣ نفّذ الـ migration
python migrate_script.py

# 3️⃣ ثم عرّف الـ Model
class OrderMaterial(db.Model):
    __tablename__ = 'order_material'
    # لا تضف __table_args__ للفهارس الموجودة
```

##### عند تعديل جدول موجود:
```python
# 1️⃣ افحص البنية الحالية
cursor.execute("PRAGMA table_info('order_material')")
columns = cursor.fetchall()

# 2️⃣ أضف الأعمدة الجديدة فقط
cursor.execute("ALTER TABLE order_material ADD COLUMN new_field TEXT")

# 3️⃣ حدّث الـ Model
class OrderMaterial(db.Model):
    __tablename__ = 'order_material'
    new_field = db.Column(db.Text)  # حقل جديد
```

#### و) معالجة الأخطاء الشائعة 🛠️

##### خطأ: `table X already exists`
```python
# الحل:
# 1. استخدم IF NOT EXISTS
CREATE TABLE IF NOT EXISTS ...

# 2. أو تحقق قبل الإنشاء
cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='X'")
if not cursor.fetchone():
    cursor.execute("CREATE TABLE ...")
```

##### خطأ: `index X already exists`
```python
# الحل:
# 1. استخدم IF NOT EXISTS
CREATE INDEX IF NOT EXISTS ...

# 2. أو احذف __table_args__ من Model إذا أُنشئت الفهارس يدوياً

# 3. أو احذف الفهرس القديم أولاً (حذر!)
DROP INDEX IF EXISTS idx_old;
CREATE INDEX idx_new ...
```

##### خطأ: `no such table: X`
```python
# الحل:
# 1. تأكد من تطابق __tablename__ مع DB
# 2. أو نفّذ db.create_all() أولاً
# 3. أو راجع migration scripts
```

#### ز) Checklist قبل التشغيل ✅

قبل تشغيل أي كود يتعامل مع قاعدة البيانات، تحقق من:

- [ ] ✅ أسماء الجداول في `__tablename__` تطابق قاعدة البيانات
- [ ] ✅ الفهارس غير مكررة (إما في migration أو في `__table_args__`)
- [ ] ✅ تم تشغيل جميع migration scripts المطلوبة
- [ ] ✅ توجد نسخة احتياطية من قاعدة البيانات
- [ ] ✅ تم اختبار الكود في بيئة تطوير أولاً
- [ ] ✅ أسماء الأعمدة متطابقة بين Model و DB
- [ ] ✅ Foreign keys صحيحة ومتطابقة
- [ ] ✅ لا توجد تعريفات مكررة في ملفات مختلفة

#### ح) أدوات مساعدة 🔧

##### سكربت فحص سريع:
```python
# check_db_consistency.py
import sqlite3
from app import db, OrderMaterial  # استورد النماذج

def check_consistency():
    # 1. افحص DB
    conn = sqlite3.connect('database.db')
    cursor = conn.cursor()
    
    # أسماء الجداول
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
    db_tables = {row[0] for row in cursor.fetchall()}
    
    # 2. افحص Models
    model_tables = {
        OrderMaterial.__tablename__,
        # أضف باقي النماذج...
    }
    
    # 3. قارن
    print("✅ موجودة في كلاهما:", db_tables & model_tables)
    print("⚠️ في DB فقط:", db_tables - model_tables)
    print("❌ في Models فقط:", model_tables - db_tables)
    
    conn.close()

if __name__ == '__main__':
    check_consistency()
```

#### ط) الفوائد 🎯
- ✅ **منع أخطاء التشغيل**: لا مزيد من `OperationalError`
- ✅ **استقرار النظام**: تطابق تام بين الكود وقاعدة البيانات
- ✅ **سهولة الصيانة**: أسماء موحدة ومفهومة
- ✅ **قابلية النقل**: يمكن استخدام القواعد في أي مشروع
- ✅ **توثيق أفضل**: بنية واضحة ومتسقة

#### ي) ملخص سريع ⚡
1. **دائماً** افحص قاعدة البيانات قبل كتابة `__tablename__`
2. **لا تُنشئ** فهارس في `__table_args__` إذا كانت موجودة في migration
3. **استخدم** `IF NOT EXISTS` في جميع عمليات الإنشاء
4. **احتفظ** بنسخ احتياطية قبل أي تعديل
5. **اختبر** في بيئة تطوير أولاً
6. **وثّق** أي انحراف عن المعايير
